{
  "hash": "9da5f730de47b028f15ab6e0e47f5a45",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n# arl_sop {#sec-doc}\n    \n\n::: {.callout-note appearance=\"simple\" title=\"docblock\" collapse=false}    \n\n\n\n\n\n\n::: {#2 .cell execution_count=0}\n``` {.julia .cell-code}\narl_sop(m::Int, n::Int, lam, cl, reps, chart_choice, dist::UnivariateDistribution)\n\n```\n:::\n\n\n\n\n\n\n\nFunction to compute the average run length (ARL) for a given control-limit and in-control distribution. The input parameters are:\n \n  * `m::Int`: The number of rows for the final \"SOP\" matrix. Note that the final spatial matrix (\"picture\") equals m + 1.\n  * `n::Int`: The number of columns for the final \"SOP\" matrix. Note that the final spatial matrix (\"picture\") equals n + 1.\n  * `lam::Float64`: A scalar value for lambda for the EWMA chart.\n  * `cl::Float64`: A scalar value for the control limit.\n  * `reps::Int`: An integer value for the number of repetitions.\n  * `chart_choice::Int`: An integer value for the chart choice. The options are 1-4.\n  * `dist::Distribution`: A distribution for the in-control data. Here you can use any univariate distribution from the `Distributions.jl` package.\n\n\n:::\n    \n\n --- \n \n::: {.callout-note appearance=\"simple\" title=\"docblock\" collapse=false}    \n\n\n\n\n\n\n::: {#4 .cell execution_count=0}\n``` {.julia .cell-code}\narl_sop(lam, cl, reps, chart_choice, data::Array{Float64, 3})\n\n```\n:::\n\n\n\n\n\n\n\nFunction to compute the average run length (ARL) using a bootstraping approach. The input parameters are:\n \n  * `lam::Float64`: A scalar value for lambda for the EWMA chart.\n  * `cl::Float64`: A scalar value for the control limit.\n  * `reps::Int`: An integer value for the number of repetitions.\n  * `chart_choice::Int`: An integer value for the chart choice. The options are 1-4.\n  * `p_mat::Array{Float64, 3}`: A 3D array with the data. The data has to be in the form of a 3D array.\n\n\n:::\n    \n\n --- \n \n::: {.callout-note appearance=\"simple\" title=\"docblock\" collapse=false}    \n\n\n\n\n\n\n::: {#6 .cell execution_count=0}\n``` {.julia .cell-code}\narl_sop(lam, cl, reps, chart_choice, spatial_dgp, dist_error::UnivariateDistribution, dist_ao::Union{Nothing, UnivariateDistribution})\n\n```\n:::\n\n\n\n\n\n\n\nFunction to compute the average run length (ARL) for a given out-of-control DGP. The input parameters are:\n \n  * `lam::Float64`: A scalar value for lambda for the EWMA chart.\n  * `cl::Float64`: A scalar value for the control limit.\n  * `chart_choice::Int`: An integer value for the chart choice. The options are 1-4.\n  * `spatial_dgp::AbstractSpatialDGP`: A struct for type for the spatial DGP. This can be either `SAR11`, `SINAR11`, `SQMA11`, `BSQMA11` or `SAR1`. Look at their documentation for more information.\n  * `dist_error::Distribution`: A distribution for the error term. Here you can use any univariate distribution from the `Distributions.jl` package.\n  * `dist_ao::Distribution`: A distribution for the out-of-control data. Here you can use any univariate distribution from the `Distributions.jl` package.\n\n\n:::\n\n\n",
    "supporting": [
      "arl_sop_files"
    ],
    "filters": [],
    "includes": {}
  }
}