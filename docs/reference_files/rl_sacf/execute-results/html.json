{
  "hash": "7663aceb3e1098631addcb753c622d55",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n# rl_sacf {#sec-doc}\n    \n\n::: {.callout-note appearance=\"simple\" title=\"docblock\" collapse=false}    \n\n\n\n\n\n\n::: {#2 .cell execution_count=0}\n``` {.julia .cell-code}\nrl_sacf(m::Int, n::Int, lam, cl, p_reps, dist_error)\n\n```\n:::\n\n\n\n\n\n\n\nCompute the in-control run length (RL) using the spatial autocorrelation function (SACF) for a lag length of 1. The function returns the RL for a given control limit `cl` and a given number of repetitions `p_reps`. The input arguments are:   \n \n  * `m::Int`: The number of rows in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\n  * `n::Int`: The number of columns in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\n  * `lam`: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\n  * `cl`: The control limit for the EWMA control chart.\n  * `p_reps`: The number of repetitions to compute the RL. This has to be a unit range of integers to allow for parallel processing, since the function is called by `arl_sacf()`.\n  * `dist_error`: The distribution to use for the error term in the SACF function.\n\n```{julia-repl}\n#| eval: false\n#--- Example\n# Set parameters\nm = 10\nn = 10\nlam = 0.1\ncl = .001\np_reps = 1:10\ndist_error = Normal(0, 1)\n\n# Compute run length\nrls = rl_sacf(m, n, lam, cl, p_reps, dist_error)\n\n```\n\n\n\n:::\n    \n\n --- \n \n::: {.callout-note appearance=\"simple\" title=\"docblock\" collapse=false}    \n\n\n\n\n\n\n::: {#4 .cell execution_count=0}\n``` {.julia .cell-code}\nrl_sacf(m::Int, n::Int, lam, cl, p_reps::UnitRange, spatial_dgp, dist_error::UnivariateDistribution, dist_ao::Union{UnivariateDistribution, Nothing})\n\n```\n:::\n\n\n\n\n\n\n\nCompute the out-of-control run length (RL) using the spatial autocorrelation function (SACF) for a lag length of 1. The function returns the RL for a given control limit `cl` and a given number of repetitions `p_reps`. The input arguments are:  \n \n  * `m::Int`: The number of rows in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\n  * `n::Int`: The number of columns in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\n  * `lam`: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\n  * `cl`: The control limit for the EWMA control chart.\n  * `p_reps`: The number of repetitions to compute the RL. This has to be a unit range of integers to allow for parallel processing, since the function is called by `arl_sacf()`.\n  * `spatial_dgp`: The spatial data generating process (DGP) to use for the SACF function. This can be one of the following: `SAR1`, `SAR11`, `SINAR11`, `SQMA11`, `SQINMA11`, or `BSQMA11`.\n  * `dist_error`: The distribution to use for the error term in the SACF function. This can be any univariate distribution from the `Distributions.jl` package with a defined mean or a custom distribution.\n  * `dist_ao`: The distribution to use for for additive outliers. This can be any univariate distribution from the `Distributions.jl` package or a custom distribution.\n\n```{julia-repl}\n#| eval: false\n#--- Example\n# Set parameters\nm = 10\nn = 10\nlam = 0.1\ncl = .001\np_reps = 1:10\nspatial_dgp = SAR11((0.1, 0.1, 0.1), 10, 10, 100)\ndist_error = Normal(0, 1)\ndist_ao = nothing\n\n# Compute run length\nrls = rl_sacf(m, n, lam, cl, p_reps, spatial_dgp, dist_error, dist_ao)\n\n```\n\n\n\n:::\n\n\n",
    "supporting": [
      "rl_sacf_files"
    ],
    "filters": [],
    "includes": {}
  }
}