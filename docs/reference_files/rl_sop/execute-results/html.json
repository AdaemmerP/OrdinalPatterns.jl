{
  "hash": "1430230a4e07e3deda09c7efa2545ee7",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n# rl_sop {#sec-doc}\n    \n\n::: {.callout-note appearance=\"simple\" title=\"docblock\" collapse=false}    \n\n\n\n\n\n\n::: {#2 .cell execution_count=0}\n``` {.julia .cell-code}\nrl_sop(m, n, lookup_array_sop, lam, cl, reps_range, chart_choice, dist)\n\n```\n:::\n\n\n\n\n\n\n\nA function to compute the run length for a given control limit and in-control distribution. The input parameters are:\n \n  * `m::Int`: The number of rows for the final \"SOP\" matrix. Note that the final spatial matrix (\"picture\") equals m + 1.\n  * `n::Int`: The number of columns for the final \"SOP\" matrix. Note that the final spatial matrix (\"picture\") equals n + 1.\n  * `lookup_array_sop::Array{Int, 4}`: A 4D array with the lookup array for the sops. This can be automatically computed using lookup*array*sop = `compute_lookup_array()`. This will be used to find the index of the sops.\n  * `lam::Float64`: A scalar value for lambda for the EWMA chart.\n  * `cl::Float64`: A scalar value for the control limit.\n  * `reps_range::UnitRange{Int}`: A range of integers for the number of repetitions. This has to be a range to be compatible with `arl_sop()` which uses threading and multi-processing.\n  * `chart_choice::Int`: An integer value for the chart choice. The options are 1-4.\n  * `dist::Distribution`: A distribution for the in-control data. Here you can use any univariate distribution from the `Distributions.jl` package.\n\n\n:::\n    \n\n --- \n \n::: {.callout-note appearance=\"simple\" title=\"docblock\" collapse=false}    \n\n\n\n\n\n\n::: {#4 .cell execution_count=0}\n``` {.julia .cell-code}\nrl_sop(lam, cl, reps_range, chart_choice, p_mat::Matrix{Float64})\n\n```\n:::\n\n\n\n\n\n\n\nA function to compute the run length for a given control limit using bootstraping instead of a theoretical in-control distribution. The input parameters are:\n \n  * `lam::Float64`: A scalar value for lambda for the EWMA chart.\n  * `cl::Float64`: A scalar value for the control limit.\n  * `reps_range::UnitRange{Int}`: A range of integers for the number of repetitions. This has to be a range to be compatible with `arl_sop()` which uses threading and multi-processing.\n  * `chart_choice::Int`: An integer value for the chart choice. The options are 1-4.\n  * `p_mat::Matrix{Float64}`: A matrix with the values of each pattern group obtained by `compute_p_mat()`. This matrix will be used for re-sampling\n\n\n:::\n    \n\n --- \n \n::: {.callout-note appearance=\"simple\" title=\"docblock\" collapse=false}    \n\n\n\n\n\n\n::: {#6 .cell execution_count=0}\n``` {.julia .cell-code}\nrl_sop(m, n, lookup_array_sop, lam, cl, p_reps, chart_choice, spatial_dgp, dist_error, dist_ao)\n\n```\n:::\n\n\n\n\n\n\n\nComputes the run length for a given out-of-control DGP. The input parameters are:\n \n  * `m::Int`: The number of rows for the final \"SOP\" matrix. Note that the final spatial matrix (\"picture\") equals m + 1.\n  * `n::Int`: The number of columns for the final \"SOP\" matrix. Note that the final spatial matrix (\"picture\") equals n + 1.\n  * `lookup_array_sop::Array{Int, 4}`: A 4D array with the lookup array for the sops. This can be automatically computed using `lookup_array_sop = compute_lookup_array()`. This will be used to find the index of the sops.\n  * `lam`: A scalar value for lambda for the EWMA chart. This has to be between 0 and 1.\n  * `cl::Float64`: A scalar value for the control limit.\n  * `p_reps::UInt`: An unsigned integer value for the number of repetitions. This has to be an unsigned integer to be compatible with `arl_sop()` which uses threading and multi-processing.\n  * `chart_choice::Int`: An integer value for the chart choice. The options are 1-4.\n  * `spatial_dgp::AbstractSpatialDGP`: A struct for type for the spatial DGP. This can be either `SAR11`, `SINAR11`, `SQMA11`, `BSQMA11` or `SAR1`. Look at their documentation for more information.\n  * `dist_error::Distribution`: A distribution for the error term. Here you can use any univariate distribution from the `Distributions.jl` package.\n  * `dist_ao::Distribution`: A distribution for the out-of-control data. Here you can use any univariate distribution from the `Distributions.jl` package.\n\n\n:::\n\n\n",
    "supporting": [
      "rl_sop_files"
    ],
    "filters": [],
    "includes": {}
  }
}