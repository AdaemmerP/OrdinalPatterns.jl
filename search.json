[
  {
    "objectID": "reference/MA2.html",
    "href": "reference/MA2.html",
    "title": "MA2",
    "section": "",
    "text": "MA2\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nMA2(α₁::Float64, α₂::Float64, dist::UnivariateDistribution)\n\nA struct to define an MA(2) process:\n\\(\\qquad X_t = α₁  \\cdot \\epsilon_{t-1} + α₂  \\cdot \\epsilon_{t-2} + \\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\nma2 = MA2(0.5, 0.3, Normal(0, 1))",
    "crumbs": [
      "API",
      "Types for ordinal patterns",
      "MA2"
    ]
  },
  {
    "objectID": "reference/dependence_op.html",
    "href": "reference/dependence_op.html",
    "title": "dependence_op",
    "section": "",
    "text": "dependence_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ndependence_op(tsx, tsy; op_length::Int=3, d=1)\n\nCompute the ordinal pattern dependence coefficient by Schnurr and Dehling (2017) doi:10.1080/01621459.2016.1164706."
  },
  {
    "objectID": "reference/BSQMA11.html",
    "href": "reference/BSQMA11.html",
    "title": "BSQMA11",
    "section": "",
    "text": "BSQMA11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nBSQMA11(dgp_params, eps_params, m, n, prerun)\n\nBilateral spatial quadratic moving-average (BSQMA(1, 1)) model as defined by Weiß and Kim (2024) on page 9. The struct contains the following fields:\n\ndgp_params::Tuple{Float64, Float64, Float64, Float64}: A tuple of the parameters of the DGP. The parameters correspond to b₁, b₂, b₃ and b₄, respectively.\neps_params::Tuple{Int, Int, Int, Int}: A tuple of the parameters of the DGP, indicating which error terms shall be squared. Note that eps_params ∈ {1, 2}.\nm::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nprerun::Int: A value to initialize the DGP. This value should be set to 1.\n\n\nbsqma11 = BSQMA11((0.5, 0.3, 0.2, 0.1), (1, 1, 2, 2), 11, 11, 1)"
  },
  {
    "objectID": "reference/sacf_11.html",
    "href": "reference/sacf_11.html",
    "title": "sacf_11",
    "section": "",
    "text": "sacf_11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nsacf_11(data, cdata, cx_t_cx_t1, cdata_sq)\n\nCompute the spatial autocorrelation function (SACF) for a given matrix data. The function returns the SACF for the first lag (ρ(1, 1)). The input arguments are:\n\ndata: A matrix of size M x N.\ncdata: A matrix of size M x N to store the demeaned data.\ncx_t_cx_t1: A matrix of size M x N to store the element-wise multiplication of the current and lagged data."
  },
  {
    "objectID": "reference/compute_p_mat.html",
    "href": "reference/compute_p_mat.html",
    "title": "compute_p_mat",
    "section": "",
    "text": "compute_p_mat\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncompute_p_mat(data::Array{Float64,3})\n\nCompute the matrix of p-hat values for a given 3D array of data. These values are used for bootstrapping."
  },
  {
    "objectID": "reference/cl_op.html",
    "href": "reference/cl_op.html",
    "title": "cl_op",
    "section": "",
    "text": "cl_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncl_op(lam, L0, op_dgp, cl_init, reps=10000; chart_choice, jmin=4, jmax=6, verbose=false, d=1, ced=false, ad=100)\n\nFunction to compute the control limit for ordinal patterns.\n\nlam::Float64: Smoothing parameter for the EWMA statistic.\nL0::Float64: In-control ARL.\nop_dgp::Union{IC, AR1, MA1, MA2, TEAR1, AAR1, QAR1}: DGP.\ncl_init::Float64: Initial guess for the control limit.\nreps::Int64: Number of replications.\nchart_choice::Int\n\n\\(\\widehat{H}^{(d)}=-\\sum_{k=1}^{m!} \\hat{p}_k{ }^{(d)} \\ln \\hat{p}_k{ }^{(d)}\\)\n\\(\\widehat{H}_{\\mathrm{ex}}^{(d)}=-\\sum_{k=1}^{m!}\\left(1-\\hat{p}_k{ }^{(d)}\\right) \\ln \\left(1-\\hat{p}_k{ }^{(d)}\\right)\\)\n\\(\\widehat{\\Delta}^{(d)}=\\sum_{k=1}^{m!}\\left(\\hat{p}_k^{(d)}-1 / m!\\right)^2\\)\n\\(\\hat{\\beta}^{(d)}=\\hat{p}_6^{(d)}-\\hat{p}_1^{(d)}\\)\n\\(\\hat{\\tau}^{(d)}=\\hat{p}_6^{(d)}+\\hat{p}_1^{(d)}-\\frac{1}{3}\\)\n\\(\\hat{\\delta}^{(d)}=\\hat{p}_4^{(d)}+\\hat{p}_5^{(d)}-\\hat{p}_3^{(d)}-\\hat{p}_2^{(d)}\\)\n\nThe patterns are categorized as follows:\n\\(\\qquad p_1 = (3,2,1);  \\quad p_2=(3,1,2);  \\quad p_3 = (2,3,1);\\)\n\\(\\qquad p_4 = (1,3,2);  \\quad p_5 = (2,1,3);  \\quad p_ 6 = (1,2,3)\\)\njmin::Int Minimum number of decimals for final control limit to optimize.\njmax::Int Maximum number of decimals for final control limit to optimize.\nverbose::Bool=false Print intermediate results?\nd::Union{Int,Vector{Int}}=1: Delay vector.\nced::Bool=false: Use conditional expected delay? Default is false.\nad::Int=100: Number of iterations for ced.",
    "crumbs": [
      "API",
      "Functions for ordinal patterns",
      "cl_op"
    ]
  },
  {
    "objectID": "reference/arl_acf.html",
    "href": "reference/arl_acf.html",
    "title": "arl_acf",
    "section": "",
    "text": "arl_acf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_acf(lam, cl, acf_dgp, reps=10000)\n\nFunction to compute the average run length (ARL) for a specified DGP using the ACF statistic by XXX.\n\nlam::Float64: Smoothing parameter for the EWMA statistic.\ncl::Float64: Control limit for the ACF statistic.\nacf_dgp::Union{IC, AR1, TEAR1}: DGP.\nreps::Int64: Number of replications.\n\n\narl_acf(0.1, 3.0, IC(Normal(0, 1)), 10000)"
  },
  {
    "objectID": "reference/BinomialC.html",
    "href": "reference/BinomialC.html",
    "title": "BinomialC",
    "section": "",
    "text": "BinomialC\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nBinomialC{T &lt;: Real}  &lt;: DiscreteUnivariateDistribution\n\nA struct to define a binomial distribution, which gets multiplied by a constant c.\n`julia-repl dist = BinomialC(0.5, 2) rand(dist)``"
  },
  {
    "objectID": "reference/PoiBin.html",
    "href": "reference/PoiBin.html",
    "title": "PoiBin",
    "section": "",
    "text": "PoiBin\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nPoiBin{T &lt;: Real}  &lt;: DiscreteUnivariateDistribution\n\nA struct to define a Poisson-Binomial distribution.\n#| eval: false\ndist = PoiBin(0.5, 5)\nrand(dist)"
  },
  {
    "objectID": "reference/count_mv_op.html",
    "href": "reference/count_mv_op.html",
    "title": "count_mv_op",
    "section": "",
    "text": "count_mv_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncount_mv_op(tsx, tsy; op_length::Int=3, d=1)\n\nCount the number of ordinal patterns in bins for two time series tsx and tsy. The output will be used to compute the ordinal pattern dependence coefficient by Schnurr and Dehling (2017) doi:10.1080/01621459.2016.1164706.\n\ntsx: First time series for which the ordinal patterns are counted.\ntsy: Second time series for which the ordinal patterns are counted.\nop_length::Int=3: Length of the ordinal patterns. Default is 3. Minimum is 2, maximum is 4.\nd::Int=1: Time delay. Default is 1.\n\n\ntsx = rand(100)\ntsy = rand(100)\ncount_mv_op(tsx, tsy; op_length=3, d=1)"
  },
  {
    "objectID": "reference/rl_sop.html",
    "href": "reference/rl_sop.html",
    "title": "rl_sop",
    "section": "",
    "text": "rl_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop(m, n, lookup_array_sop, lam, cl, reps_range, chart_choice, dist)\n\nA function to compute the run length for a given control limit and in-control distribution. The input parameters are:\n\nm::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nlookup_array_sop::Array{Int, 4}: A 4D array with the lookup array for the sops. This can be automatically computed using lookuparraysop = compute_lookup_array(). This will be used to find the index of the sops.\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nreps_range::UnitRange{Int}: A range of integers for the number of repetitions. This has to be a range to be compatible with arl_sop() which uses threading and multi-processing.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\ndist::Distribution: A distribution for the in-control data. Here you can use any univariate distribution from the Distributions.jl package.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop(lam, cl, reps_range, chart_choice, p_mat::Matrix{Float64})\n\nA function to compute the run length for a given control limit using bootstraping instead of a theoretical in-control distribution. The input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nreps_range::UnitRange{Int}: A range of integers for the number of repetitions. This has to be a range to be compatible with arl_sop() which uses threading and multi-processing.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\np_mat::Matrix{Float64}: A matrix with the values of each pattern group obtained by compute_p_mat(). This matrix will be used for re-sampling\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop(m, n, lookup_array_sop, lam, cl, p_reps, chart_choice, spatial_dgp, dist_error, dist_ao)\n\nComputes the run length for a given out-of-control DGP. The input parameters are:\n\nm::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nlookup_array_sop::Array{Int, 4}: A 4D array with the lookup array for the sops. This can be automatically computed using lookup_array_sop = compute_lookup_array(). This will be used to find the index of the sops.\nlam: A scalar value for lambda for the EWMA chart. This has to be between 0 and 1.\ncl::Float64: A scalar value for the control limit.\np_reps::UInt: An unsigned integer value for the number of repetitions. This has to be an unsigned integer to be compatible with arl_sop() which uses threading and multi-processing.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\nspatial_dgp::AbstractSpatialDGP: A struct for type for the spatial DGP. This can be either SAR11, SINAR11, SQMA11, BSQMA11 or SAR1. Look at their documentation for more information.\ndist_error::Distribution: A distribution for the error term. Here you can use any univariate distribution from the Distributions.jl package.\ndist_ao::Distribution: A distribution for the out-of-control data. Here you can use any univariate distribution from the Distributions.jl package."
  },
  {
    "objectID": "reference/rl_sacf.html",
    "href": "reference/rl_sacf.html",
    "title": "rl_sacf",
    "section": "",
    "text": "rl_sacf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sacf(m::Int, n::Int, lam, cl, p_reps, dist_error)\n\nCompute the in-control run length (RL) using the spatial autocorrelation function (SACF) for a lag length of 1. The function returns the RL for a given control limit cl and a given number of repetitions p_reps. The input arguments are:\n\nm::Int: The number of rows in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\nn::Int: The number of columns in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\np_reps: The number of repetitions to compute the RL. This has to be a unit range of integers to allow for parallel processing, since the function is called by arl_sacf().\ndist_error: The distribution to use for the error term in the SACF function.\n\n#| eval: false\n#--- Example\n# Set parameters\nm = 10\nn = 10\nlam = 0.1\ncl = .001\np_reps = 1:10\ndist_error = Normal(0, 1)\n\n# Compute run length\nrls = rl_sacf(m, n, lam, cl, p_reps, dist_error)\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sacf(m::Int, n::Int, lam, cl, p_reps::UnitRange, spatial_dgp, dist_error::UnivariateDistribution, dist_ao::Union{UnivariateDistribution, Nothing})\n\nCompute the out-of-control run length (RL) using the spatial autocorrelation function (SACF) for a lag length of 1. The function returns the RL for a given control limit cl and a given number of repetitions p_reps. The input arguments are:\n\nm::Int: The number of rows in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\nn::Int: The number of columns in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\np_reps: The number of repetitions to compute the RL. This has to be a unit range of integers to allow for parallel processing, since the function is called by arl_sacf().\nspatial_dgp: The spatial data generating process (DGP) to use for the SACF function. This can be one of the following: SAR1, SAR11, SINAR11, SQMA11, SQINMA11, or BSQMA11.\ndist_error: The distribution to use for the error term in the SACF function. This can be any univariate distribution from the Distributions.jl package with a defined mean or a custom distribution.\ndist_ao: The distribution to use for for additive outliers. This can be any univariate distribution from the Distributions.jl package or a custom distribution.\n\n#| eval: false\n#--- Example\n# Set parameters\nm = 10\nn = 10\nlam = 0.1\ncl = .001\np_reps = 1:10\nspatial_dgp = SAR11((0.1, 0.1, 0.1), 10, 10, 100)\ndist_error = Normal(0, 1)\ndist_ao = nothing\n\n# Compute run length\nrls = rl_sacf(m, n, lam, cl, p_reps, spatial_dgp, dist_error, dist_ao)"
  },
  {
    "objectID": "reference/count_uv_op.html",
    "href": "reference/count_uv_op.html",
    "title": "count_uv_op",
    "section": "",
    "text": "count_uv_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncount_uv_op(ts; op_length::Int=3, d=1)\n\nCount the number of ordinal patterns in bins for a single time series ts.\n\nts::Vector{Float64}: Time series for which the ordinal patterns are counted.\nop_length::Int=3: Length of the ordinal patterns. Default is 3. Minimum is 2, maximum is 4.\nd::Int=1: Time delay. Default is 1.\n\n\nts = rand(100)\ncount_uv_op(ts; op_length=3, d=1)"
  },
  {
    "objectID": "reference/cl_sacf.html",
    "href": "reference/cl_sacf.html",
    "title": "cl_sacf",
    "section": "",
    "text": "cl_sacf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncl_sacf(m, n, lam, L0, reps, clinit, jmin, jmax, verbose, dist_error)\n\nCompute the control limit for the exponentially weighted moving average (EWMA) control chart using the spatial autocorrelation function (SACF) for a lag length of 1. The function returns the control limit for a given average run length (ARL) L0 and a given number of repetitions reps. The input arguments are:\n\nm::Int: The number of rows in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\nn::Int: The number of columns in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\nlam: The smoothing parameter for the EWMA control chart.\nL0: The average run length (ARL) to use for the control limit.\nreps: The number of repetitions to compute the ARL.\nclinit: The initial control limit to use for the EWMA control chart. If set to 0, the function will search for the control limit that gives an ARL greater than L0.\njmin: The minimum number of values to change after the decimal point in the control limit.\njmax: The maximum number of values to change after the decimal point in the control limit.\nverbose: A boolean to indicate whether to print the control limit and ARL for each iteration.\ndist_error: The distribution to use for the error term in the SACF function. This can be any univariate distribution from the Distributions.jl package or a custom distribution with a defined method for rand() and rand!().\n\n\n#--- Example\n# Set parameters\nm = 10\nn = 10\nlam = 0.1\nL0 = 370\nreps = 1000\nclinit = 0.05\njmin = 4\njmax = 7\nverbose = true\ndist_error = Normal(0, 1)\n\n# Compute control limit\ncl = cl_sacf(m, n, lam, L0, reps, clinit, jmin, jmax, verbose, dist_error)"
  },
  {
    "objectID": "reference/chart_stat_sop.html",
    "href": "reference/chart_stat_sop.html",
    "title": "chart_stat_sop",
    "section": "",
    "text": "chart_stat_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nchart_stat_sop(p_ewma, chart_choice)\n\nCompute the the test statistic for spatial ordinal patterns. The first input is a vector with three values, based on SOP counts. The second input is the chart."
  },
  {
    "objectID": "reference/sop_frequencies.html",
    "href": "reference/sop_frequencies.html",
    "title": "sop_frequencies",
    "section": "",
    "text": "sop_frequencies\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nsop_frequencies(m::Int, n::Int, lookup_array_sop, n_sops, data, sop)\n\nCompute the frequencies of the spatial ordinal patterns. n_sops has to equal 24, as there are 4! = 24 possible patterns when using a 2x2 grid."
  },
  {
    "objectID": "reference/AR1.html",
    "href": "reference/AR1.html",
    "title": "AR1",
    "section": "",
    "text": "AR1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nAR1(α::Float64, dist::UnivariateDistribution)\n\nA struct to define an AR(1) process:\n\\(\\qquad X_t = α  \\cdot X_{t-1} + \\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\nar1 = AR1(0.5, Normal(0, 1))",
    "crumbs": [
      "API",
      "Types for ordinal patterns",
      "AR1"
    ]
  },
  {
    "objectID": "reference/compute_lookup_array.html",
    "href": "reference/compute_lookup_array.html",
    "title": "compute_lookup_array",
    "section": "",
    "text": "compute_lookup_array\n\n\n\n\n\n\ndocblock\n\n\n\n\n\nCompute a 4D array to lookup the index of the sops. The original SOPs are based on ranks. Here we use sortperm which computes the order of the elements in the vector."
  },
  {
    "objectID": "reference/SAR11.html",
    "href": "reference/SAR11.html",
    "title": "SAR11",
    "section": "",
    "text": "SAR11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSAR11(dgp_params, m, n, prerun)\n\nA struct to define a first-order spatial autoregressive (SAR(1, 1)) process:\n\\(\\qquad \\qquad Y_{t_1, t_2}=\\alpha_1 \\cdot Y_{t_1-1, t_2}+\\alpha_2 \\cdot Y_{t_1, t_2-1}+\\alpha_3 \\cdot Y_{t_1-1, t_2-1}+\\varepsilon_{t_1, t_2}\\)\n\ndgp_params::Tuple(α₁::Float64, α₂::Float64, α₃::Float64) The requirements to guarantee stationarity for the process are |α₁| &lt; 1, |α₂| &lt; 1, |α₁ + α₂| &lt; 1 - α₃, and |α₁ - α₂| &lt; 1 + α₃.\nm::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nprerun::Int: A value to initialize the DGP to achieve stationarity. These number of rows and columns will be discarded after the initialization.\n\n\nsar11 = SAR11((0.5, 0.3, 0.2), 11, 11, 100)",
    "crumbs": [
      "API",
      "Types for spatial ordinal patterns",
      "SAR11"
    ]
  },
  {
    "objectID": "reference/arl_sacf.html",
    "href": "reference/arl_sacf.html",
    "title": "arl_sacf",
    "section": "",
    "text": "arl_sacf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sacf(m::Int, n::Int, lam, cl, reps::Int, dist_error)\n\nCompute the in-control average run length (ARL), using the spatial autocorrelation function (SACF) for a lag length of 1. The function returns the ARL for a given control limit cl and a given number of repetitions reps. The input arguments are:\n\nm::Int: The number of rows in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\nn::Int: The number of columns in the matrix for the SOP matrix. Note that the original matrix will have dimensions (m + 1) x (n + 1).\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nreps: The number of repetitions to compute the ARL.\ndist_error: The distribution to use for the error term in the SACF function. This can be any univariate distribution from the Distributions.jl package or a custom distribution with a defined method for rand() and rand!().\n\n\n#--- Example\n# Set parameters\nm = 10\nn = 10\nlam = 0.1\ncl = .001\nreps = 100\ndist_error = Normal(0, 1)\n\n# Compute average run length\narl = arl_sacf(m, n, lam, cl, reps, dist_error)\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sacf(lam, cl, reps, spatial_dgp, dist_error::UnivariateDistribution, dist_ao::Union{UnivariateDistribution,Nothing})\n\nCompute the out-of-control average run length (ARL), using the spatial autocorrelation function (SACF) for a lag length of 1. The function returns the ARL for a given control limit cl and a given number of repetitions reps. The input arguments are:\n\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nreps: The number of repetitions to compute the ARL.\nspatial_dgp: The spatial data generating process (DGP) to use for the SACF function. This can be one of the following: SAR1, SAR11, SINAR11, SQMA11, SQINMA11, or BSQMA11.\ndist_error: The distribution to use for the error term in the SACF function. This can be any univariate distribution from the Distributions.jl package with a defined mean or a custom distribution.\ndist_ao: The distribution to use for additive outliers. This can be any univariate distribution from the Distributions.jl package or a custom distribution.\n\n\n#--- Example\n# Set parameters\nlam = 0.1\ncl = .001\nreps = 100\nspatial_dgp = SAR11((0.1, 0.1, 0.1), 10, 10, 100)\ndist_error = Normal(0, 1)\ndist_ao = nothing\n\n# Compute average run length\narl = arl_sacf(lam, cl, reps, spatial_dgp, dist_error, dist_ao)",
    "crumbs": [
      "API",
      "Functions for spatial ordinal patterns",
      "arl_sacf"
    ]
  },
  {
    "objectID": "reference/BinomialCvec.html",
    "href": "reference/BinomialCvec.html",
    "title": "BinomialCvec",
    "section": "",
    "text": "BinomialCvec\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nBinomialCvec{T &lt;: Real}  &lt;: DiscreteUnivariateDistribution\n\nA struct to define a binomial distribution, which gets multiplied by a value from vector c_vec.\n`julia-repl dist = BinomialCvec(0.5, [-10; 10]) rand(dist)``"
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "Tutorials\nDescribe your tutorials here."
  },
  {
    "objectID": "page_files/op.html",
    "href": "page_files/op.html",
    "title": "Ordinal Patterns",
    "section": "",
    "text": "Ordinal Patterns\nOrdinal Patterns (OPs) are a method to. They have been used in the context of …",
    "crumbs": [
      "OPs",
      "Ordinal Patterns"
    ]
  },
  {
    "objectID": "page_files/sop_replication.html",
    "href": "page_files/sop_replication.html",
    "title": "SOP Replication",
    "section": "",
    "text": "SOP Replication",
    "crumbs": [
      "SOPs",
      "SOP Replication"
    ]
  },
  {
    "objectID": "page_files/installation.html",
    "href": "page_files/installation.html",
    "title": "Installation",
    "section": "",
    "text": "Installation\nThe package is currently not registered and has to be installed manually from GitHub."
  },
  {
    "objectID": "page_files/op_replication.html",
    "href": "page_files/op_replication.html",
    "title": "Replication",
    "section": "",
    "text": "Replication",
    "crumbs": [
      "OPs",
      "Replication"
    ]
  },
  {
    "objectID": "page_files/sop_tutorial.html",
    "href": "page_files/sop_tutorial.html",
    "title": "Tutorial",
    "section": "",
    "text": "Tutorial\nThe tutorials using SOPs will be shown here…\n\n1+1\n\n2",
    "crumbs": [
      "SOPs",
      "Tutorial"
    ]
  },
  {
    "objectID": "page_files/gop_tutorials.html",
    "href": "page_files/gop_tutorials.html",
    "title": "Generalized Ordinal Patterns",
    "section": "",
    "text": "Generalized Ordinal Patterns"
  },
  {
    "objectID": "tutorials/replication_tm.html",
    "href": "tutorials/replication_tm.html",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "# Load packages\nusing OrdinalPatterns\nusing LinearAlgebra\nBLAS.set_num_threads(1); # Set BLAS threads to 1 when using multithreading\n\n# Parameters\nreps = 1_000;\nlam = 0.1\ncl = 0.03049\n\n# In-control limits SOPs\nic_sop = [\n    0.03049 0.05426 0.03174 0.05209;\n    0.02036 0.03626 0.02122 0.03476;\n    0.01223 0.0218 0.01276 0.02087;\n    0.00967 0.01724 0.01009 0.01650\n]\n\nic_sacf_cont = [0.05313, 0.03701, 0.02310, 0.01847]   \nic_sacf_count = [0.05305, 0.03698, 0.02309, 0.01847]  \n\n\n\n\n# Build struct\nsop_dgp = ICSP(\n    10,\n    10,\n    Normal(0, 1)\n)\n\n# SACF\nL0 = 370\ncl_init = 0.01\ncl_sop(lam, L0, sop_dgp, cl_init, reps; chart_choice=1, jmin=4, jmax=6, verbose=false, d=1)\n\n\n# Verify ARL\nlam = 0.1\ncl = 0.03049\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(368.527, 12.14343107153778)\n\n\n\n\n\n\nmn_vec = [(10, 10), (15, 15), (25, 25), (40, 25)]\nresults_mat = zeros(4, 5)\n\nfor (i, mn_tup) in enumerate(mn_vec)\n  m = mn_tup[1]\n  n = mn_tup[2]\n    for chart in 1:4\n        cl_sop = ic_sop[i, chart]\n        cl_sacf = ic_sacf_cont[i]      \n        sop_dgp = SAR11((0.1, 0.1, 0.1), m, n, Normal(0, 1), nothing, 100)        \n        res_sop = arl_sop(lam, cl_sop, sop_dgp, reps; chart_choice=chart, d=1)\n        res_sacf = arl_sacf(lam, cl_sacf, sop_dgp, reps)\n        results_mat[i, chart] = res_sop[1]\n        results_mat[i, 5] = res_sacf[1]\n    end\n    println(i)\nend\nround.(results_mat, digits = 2)\n\n1\n2\n3\n4\n\n\n4×5 Matrix{Float64}:\n 69.29  89.09  52.21  204.83  9.53\n 36.66  46.09  26.01  149.26  4.97\n 15.9   19.49  11.54   66.45  2.78\n 11.59  13.06   8.24   46.38  2.22\n\n\n\n\n\n\nsop_dgp = SINAR11((0.1, 0.1, 0.1), 10, 10, Poisson(5), nothing, 100)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(77.931, 2.0364413402630412)\n\n\n\n\n\n\nsop_dgp = SAR11((0.1, 0.1, 0.1), 10, 10, Normal(0, 1), BinomialC(0.1, 10), 100)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(150.843, 4.478988914106921)\n\n\n\n\n\n\nsop_dgp = SINAR11((0.1, 0.1, 0.1), 10, 10, Poisson(5), PoiBin(0.1, 25), 100)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(163.303, 4.659192125493675)\n\n\n\n\n\n\nsop_dgp = SINAR11((0.1, 0.1, 0.1), 10, 10, ZIP(5, 0.9), nothing, 100)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(6.285, 0.07275347461165046)\n\n\n\n\n\n\nsop_dgp = SQMA11((0.8, 0.8, 0.8), (2, 2, 2), 10, 10, Normal(0, 1), nothing, 1)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(13.624, 0.2409163021978062)\n\n\n\n\n\n\nsop_dgp = SQINMA11((0.8, 0.8, 0.8), (2, 2, 2), 10, 10, Poisson(5), nothing, 1)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(5.054, 0.051514442030732875)\n\n\n\n\n\n\nsop_dgp = SAR1((0.1, 0.1, 0.1, 0.1), 10, 10, Normal(0, 1), nothing, 20)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(8.712, 0.12337048381309154)\n\n\n\n\n\n\nsop_dgp = SAR1((0.1, 0.1, 0.1, 0.1), 10, 10, Normal(0, 1), BinomialCvec(0.1, [-5; 5]), 20)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(19.455, 0.38086353465779843)\n\n\n\n\n\n\nsop_dgp = BSQMA11((0.8, 0.8, 0.8, 0.8), (2, 2, 2, 2), 10, 10, Normal(0, 1), nothing, 1)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(42.957, 1.1454777476102582)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/replication_tm.html#table-1",
    "href": "tutorials/replication_tm.html#table-1",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "# Build struct\nsop_dgp = ICSP(\n    10,\n    10,\n    Normal(0, 1)\n)\n\n# SACF\nL0 = 370\ncl_init = 0.01\ncl_sop(lam, L0, sop_dgp, cl_init, reps; chart_choice=1, jmin=4, jmax=6, verbose=false, d=1)\n\n\n# Verify ARL\nlam = 0.1\ncl = 0.03049\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(368.527, 12.14343107153778)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/replication_tm.html#table-a.1",
    "href": "tutorials/replication_tm.html#table-a.1",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "mn_vec = [(10, 10), (15, 15), (25, 25), (40, 25)]\nresults_mat = zeros(4, 5)\n\nfor (i, mn_tup) in enumerate(mn_vec)\n  m = mn_tup[1]\n  n = mn_tup[2]\n    for chart in 1:4\n        cl_sop = ic_sop[i, chart]\n        cl_sacf = ic_sacf_cont[i]      \n        sop_dgp = SAR11((0.1, 0.1, 0.1), m, n, Normal(0, 1), nothing, 100)        \n        res_sop = arl_sop(lam, cl_sop, sop_dgp, reps; chart_choice=chart, d=1)\n        res_sacf = arl_sacf(lam, cl_sacf, sop_dgp, reps)\n        results_mat[i, chart] = res_sop[1]\n        results_mat[i, 5] = res_sacf[1]\n    end\n    println(i)\nend\nround.(results_mat, digits = 2)\n\n1\n2\n3\n4\n\n\n4×5 Matrix{Float64}:\n 69.29  89.09  52.21  204.83  9.53\n 36.66  46.09  26.01  149.26  4.97\n 15.9   19.49  11.54   66.45  2.78\n 11.59  13.06   8.24   46.38  2.22",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/replication_tm.html#table-a.2",
    "href": "tutorials/replication_tm.html#table-a.2",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "sop_dgp = SINAR11((0.1, 0.1, 0.1), 10, 10, Poisson(5), nothing, 100)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(77.931, 2.0364413402630412)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/replication_tm.html#table-a.3",
    "href": "tutorials/replication_tm.html#table-a.3",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "sop_dgp = SAR11((0.1, 0.1, 0.1), 10, 10, Normal(0, 1), BinomialC(0.1, 10), 100)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(150.843, 4.478988914106921)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/replication_tm.html#table-a.4",
    "href": "tutorials/replication_tm.html#table-a.4",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "sop_dgp = SINAR11((0.1, 0.1, 0.1), 10, 10, Poisson(5), PoiBin(0.1, 25), 100)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(163.303, 4.659192125493675)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/replication_tm.html#table-a.5",
    "href": "tutorials/replication_tm.html#table-a.5",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "sop_dgp = SINAR11((0.1, 0.1, 0.1), 10, 10, ZIP(5, 0.9), nothing, 100)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(6.285, 0.07275347461165046)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/replication_tm.html#table-a.6",
    "href": "tutorials/replication_tm.html#table-a.6",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "sop_dgp = SQMA11((0.8, 0.8, 0.8), (2, 2, 2), 10, 10, Normal(0, 1), nothing, 1)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(13.624, 0.2409163021978062)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/replication_tm.html#table-a.7",
    "href": "tutorials/replication_tm.html#table-a.7",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "sop_dgp = SQINMA11((0.8, 0.8, 0.8), (2, 2, 2), 10, 10, Poisson(5), nothing, 1)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(5.054, 0.051514442030732875)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/replication_tm.html#table-a.8",
    "href": "tutorials/replication_tm.html#table-a.8",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "sop_dgp = SAR1((0.1, 0.1, 0.1, 0.1), 10, 10, Normal(0, 1), nothing, 20)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(8.712, 0.12337048381309154)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/replication_tm.html#table-a.9",
    "href": "tutorials/replication_tm.html#table-a.9",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "sop_dgp = SAR1((0.1, 0.1, 0.1, 0.1), 10, 10, Normal(0, 1), BinomialCvec(0.1, [-5; 5]), 20)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(19.455, 0.38086353465779843)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/replication_tm.html#table-a.10",
    "href": "tutorials/replication_tm.html#table-a.10",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "sop_dgp = BSQMA11((0.8, 0.8, 0.8, 0.8), (2, 2, 2, 2), 10, 10, Normal(0, 1), nothing, 1)\narl_sop(lam, cl, sop_dgp, reps; chart_choice=1, d=1)\n\n(42.957, 1.1454777476102582)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "tutorials/tutorial-01.html",
    "href": "tutorials/tutorial-01.html",
    "title": "First tutorial",
    "section": "",
    "text": "First tutorial\nThis is my first tutorial!"
  },
  {
    "objectID": "page_files/sop.html",
    "href": "page_files/sop.html",
    "title": "Spatial Ordinal Patterns",
    "section": "",
    "text": "Spatial Ordinal Patterns\nSpatial Ordinal Patterns (SOPs) are a way to …",
    "crumbs": [
      "SOPs",
      "Spatial Ordinal Patterns"
    ]
  },
  {
    "objectID": "page_files/op_dependence.html",
    "href": "page_files/op_dependence.html",
    "title": "Dependency test",
    "section": "",
    "text": "Dependency test\nOrdinalPatterns.jl allows to compute the dependency statistic based on @schnurr2017.\n\nusing RCall\nusing OrdinalPatterns\nusing BenchmarkTools\n\ntsx = rand(100)\ntsy = rand(100)\n\n# R\n@rput tsx tsy \nR\"\"\"\nlibrary(ordinalpattern)\nresult_dep = patterndependence(tsx, tsy)\nresult_dep$patterncoef |&gt; print()\n\nmicrobenchmark::microbenchmark(\n  timing = patterndependence(tsx, tsy, tiesmethod=\"first\"), times = 100\n  )\n\"\"\"\n\n[1] 0.2015543\n\n\nRObject{VecSxp}\nUnit: microseconds\n   expr     min       lq     mean   median      uq      max neval\n timing 204.735 211.8785 250.5979 217.6595 231.515 1441.619   100\n\n\n\ndependence_op(tsx, tsy; op_length=3, d=1)\n@btime dependence_op(tsx, tsy; op_length=3, d=1)\n\n  7.710 μs (44 allocations: 6.41 KiB)\n\n\n(0.20155427425419903, [4, 2, 6, 3, 1, 5, 4, 1, 5, 4  …  6, 3, 2, 3, 2, 6, 6, 3, 2, 6], [4, 2, 6, 3, 5, 6, 3, 1, 5, 3  …  2, 6, 6, 3, 1, 5, 6, 3, 1, 2])\n\n\n\nchangepoint_op(tsx, tsy, op_length=3)\n\n(0.7111954033747999, 37, 0.6925264326212452, (-1.3580986393225503, 1.3580986393225503))",
    "crumbs": [
      "OPs",
      "Dependency test"
    ]
  },
  {
    "objectID": "page_files/op_tutorial.html",
    "href": "page_files/op_tutorial.html",
    "title": "Tutorial",
    "section": "",
    "text": "Tutorial",
    "crumbs": [
      "OPs",
      "Tutorial"
    ]
  },
  {
    "objectID": "page_files/op_breakpoint.html",
    "href": "page_files/op_breakpoint.html",
    "title": "Breakpoint detection",
    "section": "",
    "text": "Breakpoint detection"
  },
  {
    "objectID": "page_files/op_changepoint.html",
    "href": "page_files/op_changepoint.html",
    "title": "Changepoint test",
    "section": "",
    "text": "Changepoint test\nOrdinalPatterns.jl allows to compute the chanegpoint statistic based on @schnurr2017.\n\nusing RCall\nusing OrdinalPatterns\nusing BenchmarkTools\n\ntsx = rand(100)\ntsy = rand(100)\n\n# R\n@rput tsx tsy \nR\"\"\"\nlibrary(ordinalpattern)\nresult_dep = patterndependence(tsx, tsy)\nresult_dep$patterncoef |&gt; print()\n\nmicrobenchmark::microbenchmark(\n  timing = patterndependence(tsx, tsy, tiesmethod=\"first\"), times = 100\n  )\n\"\"\"\n\n[1] 0.04342385\n\n\nRObject{VecSxp}\nUnit: microseconds\n   expr    min      lq     mean  median      uq      max neval\n timing 202.28 211.382 249.5375 216.803 234.486 1262.763   100\n\n\n\nchangepoint_op(tsx, tsy, op_length=3)\n\n(1.078381684222567, 21, 0.19522548683379648, (-1.3580986393225503, 1.3580986393225503))",
    "crumbs": [
      "OPs",
      "Changepoint test"
    ]
  },
  {
    "objectID": "page_files/api_reference.html",
    "href": "page_files/api_reference.html",
    "title": "API",
    "section": "",
    "text": "API",
    "crumbs": [
      "API"
    ]
  },
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "Reference",
    "section": "",
    "text": "Reference\nWrite your references here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "OrdinalPatterns.jl",
    "section": "",
    "text": "OrdinalPatterns.jl is a Julia package that provides functions to conduct (sequential) tests for time series data, using ordinal patterns. The package builds on the seminal work of Bandt and Pompe (2002). The package is highly optimized and fast. The package is designed to be easy to use and provides a simple interface to compute ordinal patterns from time series data.\n\n\nThe package is currently not registered and has to be installed manually from GitHub."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "OrdinalPatterns.jl",
    "section": "",
    "text": "The package is currently not registered and has to be installed manually from GitHub."
  },
  {
    "objectID": "reference/IC.html",
    "href": "reference/IC.html",
    "title": "IC",
    "section": "",
    "text": "IC\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nIC(dist::UnivariateDistribution)\n\nA struct to define the in-control (IC) process. The struct contains one field, namely dist::UnivariateDistribution, which is the distribution of the in-control process.\n\nic = IC(Normal(0, 1))"
  },
  {
    "objectID": "reference/crit_val_sop.html",
    "href": "reference/crit_val_sop.html",
    "title": "crit_val_sop",
    "section": "",
    "text": "crit_val_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\ncritvalsop(m, n, alpha, chart_choice, approximate::Bool)\nComputes the critical value for the SOP test. Also allows the approximation of the critical value. The input parameters are:\n\nm::Int64: The number of rows in the sop-matrix. Note that the data matrix has dimensions M = m + 1.\nn::Int64: The number of columns in the sop-matrix. Note that the data matrix has dimensions N = n + 1.\nalpha::Float64: The significance level.\nchart_choice::Int64: The choice of chart.\napproximate::Bool: If true, the approximate critical value is computed. If false, the exact critical value is computed.\n\n\nExamples\n#| eval: false\n# compute approximate critical value for chart 1 \ncrit_val_sop(10, 10, 0.05, 1, true)\n\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\ncritvalsop(m, n, alpha, chart_choice, approximate::Bool)\nComputes the exact critical value for the SOP test. The input parameters are:\n\nm::Int64: The number of rows in the sop-matrix. Note that the data matrix has dimensions M = m + 1.\nn::Int64: The number of columns in the sop-matrix. Note that the data matrix has dimensions N = n + 1.\nalpha::Float64: The significance level.\nchart_choice::Int64: The choice of chart. The options are:\n\n\nExamples\n#| eval: false\n# compute approximate critical value for chart 1 \ncrit_val_sop(10, 10, 0.05, 1, true)"
  },
  {
    "objectID": "reference/ZIP.html",
    "href": "reference/ZIP.html",
    "title": "ZIP",
    "section": "",
    "text": "ZIP\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nZIP &lt;: DiscreteUnivariateDistribution\n\nA struct to define a zero-inflated Poisson distribution.\n#| eval: false\ndist = ZIP(5.0, 0.2)\nrand(dist)"
  },
  {
    "objectID": "reference/SINAR11.html",
    "href": "reference/SINAR11.html",
    "title": "SINAR11",
    "section": "",
    "text": "SINAR11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSINAR11(dgp_params, m, n, prerun)\n\nA struct to define a first-order integer spatial autoregressive (SINAR(1, 1)) model:\n\\(\\qquad X_{t_1, t_2}=\\alpha_1 \\circ X_{t_1-1, t_2}+\\alpha_2 \\circ X_{t_1, t_2-1}+\\alpha_3 \\circ X_{t_1-1, t_2-1}+\\epsilon_{t_1, t_2}.\\)\n\ndgp_params::Tuple(α₁::Float64, α₂::Float64, α₃::Float64) Note that α₁, α₂, and α₃ ∈ [0, 1) and α₁ + α₂ + α₃ &lt; 1 to guarantee stationarity.\nm::Int The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nprerun::Int A value to initialize the DGP to guarantee stationarity. These number of rows and columns will be discarded for the final spatial matrix.\n\n\nsar11 = SINAR((0.5, 0.3, 0.2), 11, 11, 100)",
    "crumbs": [
      "API",
      "Types for spatial ordinal patterns",
      "SINAR11"
    ]
  },
  {
    "objectID": "reference/arl_op.html",
    "href": "reference/arl_op.html",
    "title": "arl_op",
    "section": "",
    "text": "arl_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_op(lam, cl, op_dgp, reps=10_000; chart_choice, d=1, ced=false, ad=100)\n\nFunction to compute the average run length (ARL) for ordinal patterns using the EWMA statistic. The function implements the test statistics by Weiss and Testik (2023), who use a pattern length of 3.\n\nlam::Float64 Smoothing parameter for the EWMA statistic.\ncl::Float64 Control limit for the EWMA statistic.\nop_dgp::Union{IC, AR1, MA1, MA2, TEAR1, AAR1, QAR1} DGP.\nreps::Int64 Number of replications.\nchart_choice::Int\n\n\\(\\widehat{H}^{(d)}=-\\sum_{k=1}^{m!} \\hat{p}_k{ }^{(d)} \\ln \\hat{p}_k{ }^{(d)}\\)\n\\(\\widehat{H}_{\\mathrm{ex}}^{(d)}=-\\sum_{k=1}^{m!}\\left(1-\\hat{p}_k{ }^{(d)}\\right) \\ln \\left(1-\\hat{p}_k{ }^{(d)}\\right)\\)\n\\(\\widehat{\\Delta}^{(d)}=\\sum_{k=1}^{m!}\\left(\\hat{p}_k^{(d)}-1 / m!\\right)^2\\)\n\\(\\hat{\\beta}^{(d)}=\\hat{p}_6^{(d)}-\\hat{p}_1^{(d)}\\)\n\\(\\hat{\\tau}^{(d)}=\\hat{p}_6^{(d)}+\\hat{p}_1^{(d)}-\\frac{1}{3}\\)\n\\(\\hat{\\delta}^{(d)}=\\hat{p}_4^{(d)}+\\hat{p}_5^{(d)}-\\hat{p}_3^{(d)}-\\hat{p}_2^{(d)}\\)\n\nThe patterns are categorized as follows:\n\\(\\qquad p_1 = (3,2,1);  \\quad p_2=(3,1,2);  \\quad p_3 = (2,3,1);\\)\n\\(\\qquad p_4 = (1,3,2);  \\quad p_5 = (2,1,3);  \\quad p_ 6 = (1,2,3)\\)\nd::Union{Int,Vector{Int}}=1: Delay vector. Default is 1. A vector would denote the indices of the observations to use. For example, d = [1, 3, 4] would denote the first, third, and fourth observations.\nced::Bool=false: Use conditional expected delay? Default is false.\nad::Int=100: Number of iterations for ced.\n\n\n# Compute initial values via function cl_op()\n if j == 1 || j == 2\n      cl_init = quantile(stat_op(data, lam[i], j)[1], 0.01)                \n  else\n      cl_init = quantile(stat_op(data, lam[i], j)[1], 0.99)\nend \n\n# Run function\narl_op(0.1, cl_init, IC(Normal(0, 1)), 10_000; chart_choice=1, d=1, ced=false, ad=100)",
    "crumbs": [
      "API",
      "Functions for ordinal patterns",
      "arl_op"
    ]
  },
  {
    "objectID": "reference/AAR1.html",
    "href": "reference/AAR1.html",
    "title": "AAR1",
    "section": "",
    "text": "AAR1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nAAR1(α::Float64, dist::UnivariateDistribution)\n\nA struct to define a AAR(1) (absolute AR) process:\n\\(\\qquad X_t=\\alpha \\cdot\\left|X_{t-1}\\right|+\\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\naar1 = AAR1(0.5, Normal(0, 1))"
  },
  {
    "objectID": "reference/stat_sop.html",
    "href": "reference/stat_sop.html",
    "title": "stat_sop",
    "section": "",
    "text": "stat_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\nstatsop(data::Matrix{Float64}, chartchoice)\nComputes the test statistic for a single picture and chosen test statistic. chart_coice is an integer value for the chart choice. The options are 1-4.\n\nExamples\n#| eval: false\ndata = rand(20, 20);\n\nstat_sop(data, 2)\n\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\nstatsop(data::Array{Float64,3}, addnoise::Bool, lam::Float64, chart_choice::Int)\nComputes the test statistic for a 3D array of data, a given lambda value, and a given chart choice. The input parameters are:\n\ndata::Array{Float64,3}: A 3D array of data.\nadd_noise::Bool: A boolean value whether to add noise to the data. This is necessary when the matrices consist of count data.\nlam::Float64: A scalar value for lambda.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\n\n\nExamples\n#| eval: false\ndata = rand(20, 20, 10);\nlam = 0.1;\nchart_choice = 2;\n\nstat_sop(data, false, lam, chart_choice)"
  },
  {
    "objectID": "reference/crit_val_sacf.html",
    "href": "reference/crit_val_sacf.html",
    "title": "crit_val_sacf",
    "section": "",
    "text": "crit_val_sacf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\ncritvalsacf(M, N, alpha)\nComputes the critical value for the SACF of lag 1. The input parameters are:\n\nM::Int64: The number of rows in the data matrix.\nN::Int64: The number of columns in the data matrix.\nalpha::Float64: The significance level.\n\n\nExamples\n#| eval: false\n# compute critical value\ncrit_val_sacf(11, 11, 0.05)"
  },
  {
    "objectID": "reference/QAR1.html",
    "href": "reference/QAR1.html",
    "title": "QAR1",
    "section": "",
    "text": "QAR1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nQAR1(α::Float64, dist::UnivariateDistribution)\n\nA struct to define a QAR(1) (quadratic AR) process:\n\\(\\qquad X_t=\\alpha \\cdot X_{t-1}^2+\\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\nqar1 = QAR1(0.5, Normal(0, 1))",
    "crumbs": [
      "API",
      "Types for ordinal patterns",
      "QAR1"
    ]
  },
  {
    "objectID": "reference/rl_op.html",
    "href": "reference/rl_op.html",
    "title": "rl_op",
    "section": "",
    "text": "rl_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_op(lam, cl, lookup_array_op, p_reps, op_dgp,\n  op_dgp_dist, chart_choice; d::Union{Int,Vector{Int}}=1, ced=false, ad=100)\n\nFunction to compute run length for ordinal patterns.\n\nlam::Float64: Smoothing parameter for EWMA chart.\ncl::Float64: Control limit for the EWMA chart.\nlookup_array_op: Array to lookup ordinal patterns. Can be created with functioncomputelookuparray_op()`.\np_reps::Vector{Int}: Unit range of repetitions.\nop_dgp::Union{IC, AR1, MA1, MA2, TEAR1, AAR1, QAR1}: DGP.\nop_dgp_dist::UnivariateDistribution: Distribution of the DGP.\nchart_choice::Int: Chart choice (1: XXX, 2: XXX, 3: XXX, 4: XXX, 5: XXX, 6: XXX).\nd::Union{Int,Vector{Int}}=1: Delay vector. Default is 1.\nced::Bool=false: Use conditional expected delay? Default is false.\nad::Int=100: Number of iterations for ced.\n\n\nrl_op(0.1, 3.0, lookup_array_op, 1:10_000, IC(Normal(0, 1)), Normal(0, 1), 1; d=1, ced=false, ad=100)"
  },
  {
    "objectID": "reference/rl_acf.html",
    "href": "reference/rl_acf.html",
    "title": "rl_acf",
    "section": "",
    "text": "rl_acf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_acf(lam, cl, p_reps, acf_dgp)\n\nFunction to compute the run length (RL) for a specified DGP using the ACF statistic by XXX.\n\nlam::Float64: Smoothing parameter for the EWMA statistic.\ncl::Float64: Control limit for the ACF statistic.\np_reps::Vector{Int64}: Unit range for number of replications.\nacf_dgp::Union{IC, AR1, TEAR1}: DGP.\n\n\nrl_acf(0.1, 3.0, 10_000, IC(Normal(0, 1)))"
  },
  {
    "objectID": "reference/arl_sop.html",
    "href": "reference/arl_sop.html",
    "title": "arl_sop",
    "section": "",
    "text": "arl_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sop(m::Int, n::Int, lam, cl, reps, chart_choice, dist::UnivariateDistribution)\n\nFunction to compute the average run length (ARL) for a given control-limit and in-control distribution. The input parameters are:\n\nm::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nreps::Int: An integer value for the number of repetitions.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\ndist::Distribution: A distribution for the in-control data. Here you can use any univariate distribution from the Distributions.jl package.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sop(lam, cl, reps, chart_choice, data::Array{Float64, 3})\n\nFunction to compute the average run length (ARL) using a bootstraping approach. The input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nreps::Int: An integer value for the number of repetitions.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\np_mat::Array{Float64, 3}: A 3D array with the data. The data has to be in the form of a 3D array.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sop(lam, cl, reps, chart_choice, spatial_dgp, dist_error::UnivariateDistribution, dist_ao::Union{Nothing, UnivariateDistribution})\n\nFunction to compute the average run length (ARL) for a given out-of-control DGP. The input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\nspatial_dgp::AbstractSpatialDGP: A struct for type for the spatial DGP. This can be either SAR11, SINAR11, SQMA11, BSQMA11 or SAR1. Look at their documentation for more information.\ndist_error::Distribution: A distribution for the error term. Here you can use any univariate distribution from the Distributions.jl package.\ndist_ao::Distribution: A distribution for the out-of-control data. Here you can use any univariate distribution from the Distributions.jl package.",
    "crumbs": [
      "API",
      "Functions for spatial ordinal patterns",
      "arl_sop"
    ]
  },
  {
    "objectID": "reference/cl_acf.html",
    "href": "reference/cl_acf.html",
    "title": "cl_acf",
    "section": "",
    "text": "cl_acf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\nclacf(lam, L0, acfdgp, clinit, preps=10000; jmin=4, jmax=6, verbose=false)\nFunction to compute the control limit for the ACF statistic by XXX.\n\nlam::Float64: Smoothing parameter for the EWMA statistic.\nL0::Float64: In-control ARL.\nacf_dgp::Union{IC, AR1, TEAR1}: DGP.\ncl_init::Float64: Initial guess for the control limit.\np_reps::Int64: Number of replications.\njmin::Int64: Minimum number of iterations.\n\n\n# Compute initial values via quantiles\n\ncl_acf(0.1, 3.0, IC(Normal(0, 1)), cl_init, 10000)"
  },
  {
    "objectID": "reference/SAR1.html",
    "href": "reference/SAR1.html",
    "title": "SAR1",
    "section": "",
    "text": "SAR1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSAR1(dgp_params, eps_params, m, n, prerun)\n\nA struct to define a first-order simultaneous autoregressive (SAR(1)) model:\n\\(\\qquad Y_{t_1, t_2}=a_1 \\cdot Y_{t_1-1, t_2}+a_2 \\cdot Y_{t_1, t_2-1}+a_3 \\cdot Y_{t_1, t_2+1}+a_4 \\cdot Y_{t_1+1, t_2}+\\varepsilon_{t_1, t_2}.\\)\n\ndgp_params::Tuple{a₁::Float64, a₂::Float64, Float64, Float64}: A tuple of the parameters of the DGP. The first element is the parameter a₁, the second element is the parameter a₂, and the third element is the parameter a₃. a₄.\nm::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nmargin::Int: The margin for the spatial matrix used for initialization.\n\n\nsar1 = SAR1((0.5, 0.3, 0.2, 0.1), 11, 11, 1)",
    "crumbs": [
      "API",
      "Types for spatial ordinal patterns",
      "SAR1"
    ]
  },
  {
    "objectID": "reference/TEAR1.html",
    "href": "reference/TEAR1.html",
    "title": "TEAR1",
    "section": "",
    "text": "TEAR1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nTEAR1(α::Float64, dist::UnivariateDistribution)\n\nA struct to define a TEAR(1) process:\n\\(\\qquad X_t = B_t^{(\\alpha)} \\cdot X_{t-1}+(1-\\alpha) \\cdot \\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\ntear1 = TEAR1(0.5, Normal(0, 1))",
    "crumbs": [
      "API",
      "Types for ordinal patterns",
      "TEAR1"
    ]
  },
  {
    "objectID": "reference/SQMA11.html",
    "href": "reference/SQMA11.html",
    "title": "SQMA11",
    "section": "",
    "text": "SQMA11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSQMA11(dgp_params, eps_params, m, n, prerun)\n\nA struct to define a Spatial quadratic moving-average (SQMA(1, 1)):\n\\(\\qquad  Y_{t_1, t_2}=\\beta_1 \\cdot \\varepsilon_{t_1-1, t_2}^a+\\beta_2 \\cdot \\varepsilon_{t_1, t_2-1}^b+\\beta_3 \\cdot \\varepsilon_{t_1-1, t_2-1}^c+\\varepsilon_{t_1, t_2}\\)\n\ndgp_params::Tuple(β₁::Float64, β₂::Float64, β₃::Float64): A tuple of the parameters of the DGP. The first element is the parameter β₁, the second element is the parameter β₂, and the third element is the parameter β₃.\neps_params::Tuple(a::Int, b::Int, c::Int): A tuple of the parameters of the DGP, indicating which error terms shall be squared. Note that eps_params ∈ {1, 2}.\nm::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nprerun::Int: A value to initialize the DGP. This value should be set to 1.\n\n\nsqma11 = SQMA11((0.5, 0.3, 0.2), (1, 1, 2), 11, 11, 1)",
    "crumbs": [
      "API",
      "Types for spatial ordinal patterns",
      "SQMA11"
    ]
  },
  {
    "objectID": "reference/cl_sop.html",
    "href": "reference/cl_sop.html",
    "title": "cl_sop",
    "section": "",
    "text": "cl_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncl_sop(m::Int, n::Int, lam, L0, reps::Int, cl_init, jmin, jmax, verbose, chart_choice, dist)\n\nCompute the control limit for a given in-control distribution. The input parameters are:\n\nm::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nlam::Float64: A scalar value for lambda for the EWMA chart. The value has to be between 0 and 1.\nL0::Float64: A scalar value for the in-control ARL.\nreps::Int: An integer value for the number of repetitions.\ncl_init::Float64: A scalar value for the initial control limit. The value has to be between 0 and 1.\njmin::Int: An integer value for the minimum number of values to change after the decimal point.\njmax::Int: An integer value for the maximum number of values to change after the decimal point.\nverbose::Bool: A boolean value whether to print the control limit and ARL.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\ndist::Distribution: A distribution for the in-control data. Here you can use any univariate distribution from the Distributions.jl package. ```julia-repl #– Example\n\n\nParameters\nm = 10 n = 10 lam = 0.1 L0 = 370 reps = 10 clinit = 0.03 jmin = 4 jmax = 7 verbose = true chartchoice = 3 dist = Normal(0, 1)\nclsop(m, n, lam, L0, reps, clinit, jmin, jmax, verbose, chart_choice, dist)"
  },
  {
    "objectID": "reference/changepoint_op.html",
    "href": "reference/changepoint_op.html",
    "title": "changepoint_op",
    "section": "",
    "text": "changepoint_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nchangepoint_op(tsx, tsy; conf_level=0.95, weight=true, bn=log(length(tsx)), op_length::Int=3, d=1)\n\nCompute the changepoint in dependence between two time series based on Schnurr and Dehling (2017) doi:10.1080/01621459.2016.1164706.\n\ntsx: First time series for which the ordinal patterns are counted.\ntsy: Second time series for which the ordinal patterns are counted.\nconf_level::Float64=0.95: Confidence level for the changepoint detection. Default is 0.95.\nweight::Bool=true: Whether to use a weight function. Default is true.\nbn::Float64=log(length(tsx)): Bandwidth for the kernel function. Default is log(length(tsx)).\nop_length::Int=3: Length of the ordinal patterns. Default is 3. Minimum is 2, maximum is 4.\nd::Int=1: Time delay. Default is 1.\n\n\ntsx = rand(100)\ntsy = rand(100)\nchangepoint_op(tsx, tsy; conf_level=0.95, weight=true, bn=log(length(tsx)), op_length=3, d=1)"
  },
  {
    "objectID": "reference/MA1.html",
    "href": "reference/MA1.html",
    "title": "MA1",
    "section": "",
    "text": "MA1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nMA1(α::Float64, dist::UnivariateDistribution)\n\nA struct to define an MA(1) process:\n\\(\\qquad X_t = α  \\cdot \\epsilon_{t-1} + \\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\nma1 = MA1(0.5, Normal(0, 1))",
    "crumbs": [
      "API",
      "Types for ordinal patterns",
      "MA1"
    ]
  },
  {
    "objectID": "reference/SQINMA11.html",
    "href": "reference/SQINMA11.html",
    "title": "SQINMA11",
    "section": "",
    "text": "SQINMA11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSQINMA11(dgp_params, eps_params, m, n, prerun)\n\nA struct to define a Spatial quadratic integer moving-average SQINMA(1, 1):\n\\(\\qquad X_{t_1, t_2}=\\beta_1 \\circ \\epsilon_{t_1-1, t_2}^a+\\beta_2 \\circ \\epsilon_{t_1, t_2-1}^b+\\beta_3 \\circ \\epsilon_{t_1-1, t_2-1}^c+\\epsilon_{t_1, t_2}.\\)\n\ndgp_params::Tuple(β₁::Float64, β₂::Float64, β₃::Float64). Note that β₁, β₂, and β₃ ∈ [0, 1].\neps_params::Tuple(a::Int, b::Int, c::Int). A tuple of the parameters of the DGP, indicating which error terms shall be squared. Note that eps_params ∈ {1, 2}.\nm::Int. The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int. The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nprerun::Int. A value to initialize the DGP. This value should be set to 1.\n\n\nsqinma11 = SQINMA11((0.5, 0.3, 0.2), (1, 1, 2), 11, 11, 1)",
    "crumbs": [
      "API",
      "Types for spatial ordinal patterns",
      "SQINMA11"
    ]
  }
]